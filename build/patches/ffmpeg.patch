--- ./configure	2022-02-15 22:51:57.000000000 +0100
+++ ./configure	2022-02-15 22:53:18.000000000 +0100
@@ -6488,9 +6488,7 @@
 done
 
 # these are off by default, so fail if requested and not available
-enabled avisynth          && { require_headers "avisynth/avisynth_c.h avisynth/avs/version.h" &&
-                               { test_cpp_condition avisynth/avs/version.h "AVS_MAJOR_VER >= 3 && AVS_MINOR_VER >= 7 && AVS_BUGFIX_VER >= 1 || AVS_MAJOR_VER >= 3 && AVS_MINOR_VER > 7 || AVS_MAJOR_VER > 3" ||
-                                 die "ERROR: AviSynth+ header version must be >= 3.7.1"; } }
+enabled avisynth          && require_pkg_config avisynth "avisynth >= 3.7.0" "avisynth/avisynth_c.h" avs_get_version
 enabled cuda_nvcc         && { check_nvcc cuda_nvcc || die "ERROR: failed checking for nvcc."; }
 enabled chromaprint       && require chromaprint chromaprint.h chromaprint_get_version -lchromaprint
 enabled decklink          && { require_headers DeckLinkAPI.h &&
--- ./libavformat/avisynth.c	2022-03-03 18:20:02.000000000 +0100
+++ ./libavformat/avisynth.c	2022-03-04 17:15:43.000000000 +0100
@@ -28,19 +28,6 @@
 #include "internal.h"
 #include "config.h"
 
-/* Enable function pointer definitions for runtime loading. */
-#define AVSC_NO_DECLSPEC
-
-/* Platform-specific directives. */
-#ifdef _WIN32
-  #include "compat/w32dlfcn.h"
-  #undef EXTERN_C
-  #define AVISYNTH_LIB "avisynth"
-#else
-  #include <dlfcn.h>
-  #define AVISYNTH_NAME "libavisynth"
-  #define AVISYNTH_LIB AVISYNTH_NAME SLIBSUF
-#endif
 
 /* Endianness guards for audio */
 #if HAVE_BIGENDIAN
@@ -51,38 +38,6 @@
 
 #include <avisynth/avisynth_c.h>
 
-typedef struct AviSynthLibrary {
-    void *library;
-#define AVSC_DECLARE_FUNC(name) name ## _func name
-    AVSC_DECLARE_FUNC(avs_bit_blt);
-    AVSC_DECLARE_FUNC(avs_clip_get_error);
-    AVSC_DECLARE_FUNC(avs_create_script_environment);
-    AVSC_DECLARE_FUNC(avs_delete_script_environment);
-    AVSC_DECLARE_FUNC(avs_get_audio);
-    AVSC_DECLARE_FUNC(avs_get_error);
-    AVSC_DECLARE_FUNC(avs_get_frame);
-    AVSC_DECLARE_FUNC(avs_get_version);
-    AVSC_DECLARE_FUNC(avs_get_video_info);
-    AVSC_DECLARE_FUNC(avs_invoke);
-    AVSC_DECLARE_FUNC(avs_is_color_space);
-    AVSC_DECLARE_FUNC(avs_release_clip);
-    AVSC_DECLARE_FUNC(avs_release_value);
-    AVSC_DECLARE_FUNC(avs_release_video_frame);
-    AVSC_DECLARE_FUNC(avs_take_clip);
-    AVSC_DECLARE_FUNC(avs_bits_per_pixel);
-    AVSC_DECLARE_FUNC(avs_get_height_p);
-    AVSC_DECLARE_FUNC(avs_get_pitch_p);
-    AVSC_DECLARE_FUNC(avs_get_read_ptr_p);
-    AVSC_DECLARE_FUNC(avs_get_row_size_p);
-    AVSC_DECLARE_FUNC(avs_is_planar_rgb);
-    AVSC_DECLARE_FUNC(avs_is_planar_rgba);
-    AVSC_DECLARE_FUNC(avs_get_frame_props_ro);
-    AVSC_DECLARE_FUNC(avs_prop_get_int);
-    AVSC_DECLARE_FUNC(avs_prop_get_type);
-    AVSC_DECLARE_FUNC(avs_get_env_property);
-#undef AVSC_DECLARE_FUNC
-} AviSynthLibrary;
-
 typedef struct AviSynthContext {
     AVS_ScriptEnvironment *env;
     AVS_Clip *clip;
@@ -113,64 +68,6 @@
 static const int avs_planes_rgba[4]   = { AVS_PLANAR_G, AVS_PLANAR_B,
                                           AVS_PLANAR_R, AVS_PLANAR_A };
 
-/* A conflict between C++ global objects, atexit, and dynamic loading requires
- * us to register our own atexit handler to prevent double freeing. */
-static AviSynthLibrary avs_library;
-static int avs_atexit_called        = 0;
-
-/* Linked list of AviSynthContexts. An atexit handler destroys this list. */
-static AviSynthContext *avs_ctx_list = NULL;
-
-static av_cold void avisynth_atexit_handler(void);
-
-static av_cold int avisynth_load_library(void)
-{
-    avs_library.library = dlopen(AVISYNTH_LIB, RTLD_NOW | RTLD_LOCAL);
-    if (!avs_library.library)
-        return AVERROR_UNKNOWN;
-
-#define LOAD_AVS_FUNC(name, continue_on_fail)                          \
-        avs_library.name = (name ## _func)                             \
-                           dlsym(avs_library.library, #name);          \
-        if (!continue_on_fail && !avs_library.name)                    \
-            goto fail;
-
-    LOAD_AVS_FUNC(avs_bit_blt, 0);
-    LOAD_AVS_FUNC(avs_clip_get_error, 0);
-    LOAD_AVS_FUNC(avs_create_script_environment, 0);
-    LOAD_AVS_FUNC(avs_delete_script_environment, 0);
-    LOAD_AVS_FUNC(avs_get_audio, 0);
-    LOAD_AVS_FUNC(avs_get_error, 1); // New to AviSynth 2.6
-    LOAD_AVS_FUNC(avs_get_frame, 0);
-    LOAD_AVS_FUNC(avs_get_version, 0);
-    LOAD_AVS_FUNC(avs_get_video_info, 0);
-    LOAD_AVS_FUNC(avs_invoke, 0);
-    LOAD_AVS_FUNC(avs_is_color_space, 1);
-    LOAD_AVS_FUNC(avs_release_clip, 0);
-    LOAD_AVS_FUNC(avs_release_value, 0);
-    LOAD_AVS_FUNC(avs_release_video_frame, 0);
-    LOAD_AVS_FUNC(avs_take_clip, 0);
-    LOAD_AVS_FUNC(avs_bits_per_pixel, 1);
-    LOAD_AVS_FUNC(avs_get_height_p, 1);
-    LOAD_AVS_FUNC(avs_get_pitch_p, 1);
-    LOAD_AVS_FUNC(avs_get_read_ptr_p, 1);
-    LOAD_AVS_FUNC(avs_get_row_size_p, 1);
-    LOAD_AVS_FUNC(avs_is_planar_rgb, 1);
-    LOAD_AVS_FUNC(avs_is_planar_rgba, 1);
-    LOAD_AVS_FUNC(avs_get_frame_props_ro, 1);
-    LOAD_AVS_FUNC(avs_prop_get_int, 1);
-    LOAD_AVS_FUNC(avs_prop_get_type, 1);
-    LOAD_AVS_FUNC(avs_get_env_property, 1);
-#undef LOAD_AVS_FUNC
-
-    atexit(avisynth_atexit_handler);
-    return 0;
-
-fail:
-    dlclose(avs_library.library);
-    return AVERROR_UNKNOWN;
-}
-
 /* Note that avisynth_context_create and avisynth_context_destroy
  * do not allocate or free the actual context! That is taken care of
  * by libavformat. */
@@ -179,67 +76,30 @@
     AviSynthContext *avs = s->priv_data;
     int ret;
 
-    if (!avs_library.library)
-        if (ret = avisynth_load_library())
-            return ret;
-
-    avs->env = avs_library.avs_create_script_environment(3);
-    if (avs_library.avs_get_error) {
-        const char *error = avs_library.avs_get_error(avs->env);
+    avs->env = avs_create_script_environment(3);
+    if (avs_get_error) {
+        const char *error = avs_get_error(avs->env);
         if (error) {
             av_log(s, AV_LOG_ERROR, "%s\n", error);
             return AVERROR_UNKNOWN;
         }
     }
 
-    if (!avs_ctx_list) {
-        avs_ctx_list = avs;
-    } else {
-        avs->next    = avs_ctx_list;
-        avs_ctx_list = avs;
-    }
-
     return 0;
 }
 
 static av_cold void avisynth_context_destroy(AviSynthContext *avs)
 {
-    if (avs_atexit_called)
-        return;
-
-    if (avs == avs_ctx_list) {
-        avs_ctx_list = avs->next;
-    } else {
-        AviSynthContext *prev = avs_ctx_list;
-        while (prev->next != avs)
-            prev = prev->next;
-        prev->next = avs->next;
-    }
-
     if (avs->clip) {
-        avs_library.avs_release_clip(avs->clip);
+        avs_release_clip(avs->clip);
         avs->clip = NULL;
     }
     if (avs->env) {
-        avs_library.avs_delete_script_environment(avs->env);
+        avs_delete_script_environment(avs->env);
         avs->env = NULL;
     }
 }
 
-static av_cold void avisynth_atexit_handler(void)
-{
-    AviSynthContext *avs = avs_ctx_list;
-
-    while (avs) {
-        AviSynthContext *next = avs->next;
-        avisynth_context_destroy(avs);
-        avs = next;
-    }
-    dlclose(avs_library.library);
-
-    avs_atexit_called = 1;
-}
-
 /* Create AVStream from audio and video data. */
 static int avisynth_create_stream_video(AVFormatContext *s, AVStream *st)
 {
@@ -507,16 +367,16 @@
      * version 9 at the minimum.  Technically, 8.1 works, but the time
      * distance between 8.1 and 9 is very small, so just restrict it to 9. */
 
-    if (avs_library.avs_get_version(avs->clip) >= 9) {
+    if (avs_get_version(avs->clip) >= 9) {
 
-        frame  = avs_library.avs_get_frame(avs->clip, 0);
-        avsmap = avs_library.avs_get_frame_props_ro(avs->env, frame);
+        frame  = avs_get_frame(avs->clip, 0);
+        avsmap = avs_get_frame_props_ro(avs->env, frame);
 
         /* Field order */
-        if(avs_library.avs_prop_get_type(avs->env, avsmap, "_FieldBased") == AVS_PROPTYPE_UNSET) {
+        if(avs_prop_get_type(avs->env, avsmap, "_FieldBased") == AVS_PROPTYPE_UNSET) {
             st->codecpar->field_order = AV_FIELD_UNKNOWN;
         } else {
-            switch (avs_library.avs_prop_get_int(avs->env, avsmap, "_FieldBased", 0, &error)) {
+            switch (avs_prop_get_int(avs->env, avsmap, "_FieldBased", 0, &error)) {
             case 0:
                 st->codecpar->field_order = AV_FIELD_PROGRESSIVE;
                 break;
@@ -532,10 +392,10 @@
         }
 
         /* Color Range */
-        if(avs_library.avs_prop_get_type(avs->env, avsmap, "_ColorRange") == AVS_PROPTYPE_UNSET) {
+        if(avs_prop_get_type(avs->env, avsmap, "_ColorRange") == AVS_PROPTYPE_UNSET) {
             st->codecpar->color_range = AVCOL_RANGE_UNSPECIFIED;
         } else {
-            switch (avs_library.avs_prop_get_int(avs->env, avsmap, "_ColorRange", 0, &error)) {
+            switch (avs_prop_get_int(avs->env, avsmap, "_ColorRange", 0, &error)) {
             case 0:
                 st->codecpar->color_range = AVCOL_RANGE_JPEG;
                 break;
@@ -548,7 +408,7 @@
         }
 
         /* Color Primaries */
-        switch (avs_library.avs_prop_get_int(avs->env, avsmap, "_Primaries", 0, &error)) {
+        switch (avs_prop_get_int(avs->env, avsmap, "_Primaries", 0, &error)) {
         case 1:
             st->codecpar->color_primaries = AVCOL_PRI_BT709;
             break;
@@ -590,7 +450,7 @@
         }
 
         /* Color Transfer Characteristics */
-        switch (avs_library.avs_prop_get_int(avs->env, avsmap, "_Transfer", 0, &error)) {
+        switch (avs_prop_get_int(avs->env, avsmap, "_Transfer", 0, &error)) {
         case 1:
             st->codecpar->color_trc = AVCOL_TRC_BT709;
             break;
@@ -647,10 +507,10 @@
         }
 
         /* Matrix coefficients */
-        if(avs_library.avs_prop_get_type(avs->env, avsmap, "_Matrix") == AVS_PROPTYPE_UNSET) {
+        if(avs_prop_get_type(avs->env, avsmap, "_Matrix") == AVS_PROPTYPE_UNSET) {
             st->codecpar->color_space = AVCOL_SPC_UNSPECIFIED;
         } else {
-            switch (avs_library.avs_prop_get_int(avs->env, avsmap, "_Matrix", 0, &error)) {
+            switch (avs_prop_get_int(avs->env, avsmap, "_Matrix", 0, &error)) {
             case 0:
                 st->codecpar->color_space = AVCOL_SPC_RGB;
                 break;
@@ -699,10 +559,10 @@
         }
 
         /* Chroma Location */
-        if(avs_library.avs_prop_get_type(avs->env, avsmap, "_ChromaLocation") == AVS_PROPTYPE_UNSET) {
+        if(avs_prop_get_type(avs->env, avsmap, "_ChromaLocation") == AVS_PROPTYPE_UNSET) {
             st->codecpar->chroma_location = AVCHROMA_LOC_UNSPECIFIED;
         } else {
-            switch (avs_library.avs_prop_get_int(avs->env, avsmap, "_ChromaLocation", 0, &error)) {
+            switch (avs_prop_get_int(avs->env, avsmap, "_ChromaLocation", 0, &error)) {
             case 0:
                 st->codecpar->chroma_location = AVCHROMA_LOC_LEFT;
                 break;
@@ -826,7 +686,7 @@
 #else
     arg = avs_new_value_string(s->url);
 #endif
-    val = avs_library.avs_invoke(avs->env, "Import", arg, 0);
+    val = avs_invoke(avs->env, "Import", arg, 0);
     if (avs_is_error(val)) {
         av_log(s, AV_LOG_ERROR, "%s\n", avs_as_error(val));
         ret = AVERROR_UNKNOWN;
@@ -838,14 +698,14 @@
         goto fail;
     }
 
-    avs->clip = avs_library.avs_take_clip(val, avs->env);
-    avs->vi   = avs_library.avs_get_video_info(avs->clip);
+    avs->clip = avs_take_clip(val, avs->env);
+    avs->vi   = avs_get_video_info(avs->clip);
 
     /* On Windows, FFmpeg supports AviSynth interface version 6 or higher.
      * This includes AviSynth 2.6 RC1 or higher, and AviSynth+ r1718 or higher,
      * and excludes 2.5 and the 2.6 alphas. */
 
-    if (avs_library.avs_get_version(avs->clip) < 6) {
+    if (avs_get_version(avs->clip) < 6) {
         av_log(s, AV_LOG_ERROR,
                "AviSynth version is too old. Please upgrade to either AviSynth 2.6 >= RC1 or AviSynth+ >= r1718.\n");
         ret = AVERROR_UNKNOWN;
@@ -853,7 +713,7 @@
     }
 
     /* Release the AVS_Value as it will go out of scope. */
-    avs_library.avs_release_value(val);
+    avs_release_value(val);
 
     if (ret = avisynth_create_stream(s))
         goto fail;
@@ -901,7 +761,7 @@
     if (discard)
         return 0;
 
-    bits = avs_library.avs_bits_per_pixel(avs->vi);
+    bits = avs_bits_per_pixel(avs->vi);
 
     /* Without the cast to int64_t, calculation overflows at about 9k x 9k
      * resolution. */
@@ -918,8 +778,8 @@
     pkt->duration = 1;
     pkt->stream_index = avs->curr_stream;
 
-    frame = avs_library.avs_get_frame(avs->clip, n);
-    error = avs_library.avs_clip_get_error(avs->clip);
+    frame = avs_get_frame(avs->clip, n);
+    error = avs_clip_get_error(avs->clip);
     if (error) {
         av_log(s, AV_LOG_ERROR, "%s\n", error);
         avs->error = 1;
@@ -930,26 +790,26 @@
     dst_p = pkt->data;
     for (i = 0; i < avs->n_planes; i++) {
         plane = avs->planes[i];
-        src_p = avs_library.avs_get_read_ptr_p(frame, plane);
-        pitch = avs_library.avs_get_pitch_p(frame, plane);
+        src_p = avs_get_read_ptr_p(frame, plane);
+        pitch = avs_get_pitch_p(frame, plane);
 
-        rowsize     = avs_library.avs_get_row_size_p(frame, plane);
-        planeheight = avs_library.avs_get_height_p(frame, plane);
+        rowsize     = avs_get_row_size_p(frame, plane);
+        planeheight = avs_get_height_p(frame, plane);
 
         /* Flip RGB video. */
-        if (avs_library.avs_is_color_space(avs->vi, AVS_CS_BGR)   ||
-            avs_library.avs_is_color_space(avs->vi, AVS_CS_BGR48) ||
-            avs_library.avs_is_color_space(avs->vi, AVS_CS_BGR64)) {
+        if (avs_is_color_space(avs->vi, AVS_CS_BGR)   ||
+            avs_is_color_space(avs->vi, AVS_CS_BGR48) ||
+            avs_is_color_space(avs->vi, AVS_CS_BGR64)) {
             src_p = src_p + (planeheight - 1) * pitch;
             pitch = -pitch;
         }
 
-        avs_library.avs_bit_blt(avs->env, dst_p, rowsize, src_p, pitch,
+        avs_bit_blt(avs->env, dst_p, rowsize, src_p, pitch,
                                  rowsize, planeheight);
         dst_p += rowsize * planeheight;
     }
 
-    avs_library.avs_release_video_frame(frame);
+    avs_release_video_frame(frame);
     return 0;
 }
 
@@ -1009,8 +869,8 @@
     pkt->duration = samples;
     pkt->stream_index = avs->curr_stream;
 
-    avs_library.avs_get_audio(avs->clip, pkt->data, n, samples);
-    error = avs_library.avs_clip_get_error(avs->clip);
+    avs_get_audio(avs->clip, pkt->data, n, samples);
+    error = avs_clip_get_error(avs->clip);
     if (error) {
         av_log(s, AV_LOG_ERROR, "%s\n", error);
         avs->error = 1;
